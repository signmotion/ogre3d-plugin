#pragma once

#include <Ogre.h>
#include "default.h"
#include "Safethread.h"


/**
* Порт - абстракция, позволяющая моделировать взаимодействия в мире, собрав
* его элементы в качестве абстрактных сущностей с определёнными
* характеристиками и правилами взаимодействия.
*
* Пример 1. Звёздная система может быть представлена сферами с некоторой
* массой, взаимодействующих согласно закону всемирного тяготения. Более того,
* рассчёт новых состояний системы может проводится не так часто, как расчёт
* состояний сущностей, скажем, на самих планетах.
*
* Пример 2. Чтобы смоделировать распространение газа, мир может быть разбит
* на ячейки, каждая из которых будет содержать информацию о количестве газа
* в ней, препятствиях и пустотах, определяющих правила распространения газа.
*
* Пример 3. Если моделируем перемещение объектов в большом мире, не эффективно
* держать в памяти все объекты и считать далёкие от наблюдателя взаимодействия
* в реальном времени. Т.о. может быть создан порт для обсчёта дальних объектов,
* со своей картой и частотой интервалов.
*
* Благодаря введению портов имеем:
*   - другое представление (структуры) для сущностей
*   - другие масштабы
*   - другое время
* => эффективное использование ресурсов.
*
* @see RealtimePort
* @see Проект Sample_SmokePort2D
*/
class Port : public Safethread {
public:
    /**
    * Порт может уметь себя визуализировать. Если такой надобности нет,
    * параметры можно упустить.
    */
    Port( Ogre::SceneManager* sm );



    virtual inline ~Port() {
        std::cout << "~Port()" << std::endl;
        /* - @todo ? Ошибка.
        if ( sn ) {
            try {
                sn->removeAndDestroyAllChildren();
            } catch ( ... ) {
            }
        }
        */
    }





    /**
    * Переводит порт в следующее состояние.
    * Отвечает за все изменения содержимого порта включая его визуальный образ.
    *
    * Порт не декларирует отдельные методы для изменения образа / характеристик,
    * т.к. может оказаться эффективней реализовать эти изменения в рамках одного
    * метода. Например, когда моделируем физику и желаем тут же отразить
    * изменения на сцене.
    *
    * @param tact Количество тактов, которые должны быть просчитаны для порта.
    *        Может быть нулевым (означает: "только визуализировать содержимое").
    *        Может быть отрицательным ("обратный отсчёт времени").
    * @param timestep Интервал времени в секундах для расчёта взаимодействий.
    *        Чем меньше - тем быстрее. При tact == 0, timestep не учитывается.
    */
    virtual void pulse( int tact, float timestep ) = 0;




    /**
    * @return Количество сущностей, размещённый в порту.
    */
    virtual size_t count() = 0;






protected:
    /**
    * Всё что нужно для визуализации содержимого порта.
    */
    Ogre::SceneManager* sm;

    /**
    * Визуализацию проводим с помощью акторов.
    *//* - Непредсказуемо вылетает. Заменено на вызов статических методов
           для отрисовки.
    std::shared_ptr< Theron::Framework >  drawFlicker;
    Theron::ActorRef drawActor;
    */

};
